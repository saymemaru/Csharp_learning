//数组类型是引用类型，即使元素类型是值类型（所以即便int 是值类型，int[] 仍是引用类型）；
//枚举（使用enum 来声明）是值类型；
//委托类型（使用delegate 来声明）是引用类型；
//接口类型（使用interface 来声明）是引用类型，但可由值类型实现。
//类（使用class 来声明）是引用类型，而结构（使用struct 来声明）是值类型

//引用类型的对象总是在堆上，值类型的值既可能在栈上，也可能在堆上，具体取决于上下文。
using 对象与类;

//类类型，修改任意一个引用，另一个引用也会改变
人类 小王 = new 人类("小王", 25);
人类 小王拷贝 = 小王; //引用类型，赋值的是引用
Console.WriteLine($"小王年龄{小王.年龄},小王拷贝年龄{小王拷贝.年龄}");
小王.年龄 = 30;
Console.WriteLine($"小王年龄{小王.年龄},小王拷贝年龄{小王拷贝.年龄}");
小王拷贝.年龄 = 35;
Console.WriteLine($"小王年龄{小王.年龄},小王拷贝年龄{小王拷贝.年龄}");

Console.WriteLine();
//值类型，修改一个值，另一个值不变
int 小王年龄 = 25;
int 小王年龄拷贝 = 小王年龄;
Console.WriteLine($"小王年龄{小王年龄},小王拷贝年龄{小王年龄拷贝}");
小王年龄 = 30;
Console.WriteLine($"小王年龄{小王年龄},小王拷贝年龄{小王年龄拷贝}");
小王年龄拷贝 = 35;
Console.WriteLine($"小王年龄{小王年龄},小王拷贝年龄{小王年龄拷贝}");

//当你给方法传递参数时，即使参数是引用类型，传递的也是"引用的值"，而不是引用本身
//永远不会 传递对象本身
void 方法值传递(人类 person)
{
    person.年龄 = 40;
    Console.WriteLine($"{person.年龄}");
}

//装箱与拆箱：当你很想把一个值类型当作引用类型来使用（消耗性能）
//装箱：把值类型转换为引用类型的过程
//拆箱：把引用类型转换为值类型的过程
int i = 5;
object o = i;
int j = (int)o;